
---
apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.2.4
  creationTimestamp: null
  name: lkes.linode.stack.crossplane.io
spec:
  group: linode.stack.crossplane.io
  names:
    kind: Lke
    listKind: LkeList
    plural: lkes
    singular: lke
  scope: Namespaced
  validation:
    openAPIV3Schema:
      description: Lke is the Schema for the lkes API
      properties:
        apiVersion:
          description: 'APIVersion defines the versioned schema of this representation
            of an object. Servers should convert recognized schemas to the latest
            internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
          type: string
        kind:
          description: 'Kind is a string value representing the REST resource this
            object represents. Servers may infer this from the endpoint the client
            submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
          type: string
        metadata:
          type: object
        spec:
          description: LkeSpec defines the desired state of Lke
          properties:
            label:
              type: string
            node_pools:
              description: 'INSERT ADDITIONAL SPEC FIELDS - desired state of cluster
                Important: Run "make" to regenerate code after modifying this file'
              items: {}
              type: array
            region:
              type: string
            tags:
              items:
                type: string
              type: array
            version:
              type: string
          required:
          - label
          - node_pools
          - region
          - version
          type: object
        status:
          description: LkeStatus defines the observed state of Lke
          properties:
            created:
              description: "A Time represents an instant in time with nanosecond precision.
                \n Programs using times should typically store and pass them as values,
                not pointers. That is, time variables and struct fields should be
                of type time.Time, not *time.Time. \n A Time value can be used by
                multiple goroutines simultaneously except that the methods GobDecode,
                UnmarshalBinary, UnmarshalJSON and UnmarshalText are not concurrency-safe.
                \n Time instants can be compared using the Before, After, and Equal
                methods. The Sub method subtracts two instants, producing a Duration.
                The Add method adds a Time and a Duration, producing a Time. \n The
                zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
                As this time is unlikely to come up in practice, the IsZero method
                gives a simple way of detecting a time that has not been initialized
                explicitly. \n Each Time has associated with it a Location, consulted
                when computing the presentation form of the time, such as in the Format,
                Hour, and Year methods. The methods Local, UTC, and In return a Time
                with a specific location. Changing the location in this way changes
                only the presentation; it does not change the instant in time being
                denoted and therefore does not affect the computations described in
                earlier paragraphs. \n Representations of a Time value saved by the
                GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store
                the Time.Location's offset, but not the location name. They therefore
                lose information about Daylight Saving Time. \n In addition to the
                required “wall clock” reading, a Time may contain an optional reading
                of the current process's monotonic clock, to provide additional precision
                for comparison or subtraction. See the “Monotonic Clocks” section
                in the package documentation for details. \n Note that the Go == operator
                compares not just the time instant but also the Location and the monotonic
                clock reading. Therefore, Time values should not be used as map or
                database keys without first guaranteeing that the identical Location
                has been set for all values, which can be achieved through use of
                the UTC or Local method, and that the monotonic clock reading has
                been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
                to t == u, since t.Equal uses the most accurate comparison available
                and correctly handles the case when only one of its arguments has
                a monotonic clock reading."
              type: object
            id:
              description: 'INSERT ADDITIONAL STATUS FIELD - define observed state
                of cluster Important: Run "make" to regenerate code after modifying
                this file'
              type: integer
            label:
              type: string
            region:
              type: string
            status:
              type: string
            tags:
              items:
                type: string
              type: array
            updated:
              description: "A Time represents an instant in time with nanosecond precision.
                \n Programs using times should typically store and pass them as values,
                not pointers. That is, time variables and struct fields should be
                of type time.Time, not *time.Time. \n A Time value can be used by
                multiple goroutines simultaneously except that the methods GobDecode,
                UnmarshalBinary, UnmarshalJSON and UnmarshalText are not concurrency-safe.
                \n Time instants can be compared using the Before, After, and Equal
                methods. The Sub method subtracts two instants, producing a Duration.
                The Add method adds a Time and a Duration, producing a Time. \n The
                zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
                As this time is unlikely to come up in practice, the IsZero method
                gives a simple way of detecting a time that has not been initialized
                explicitly. \n Each Time has associated with it a Location, consulted
                when computing the presentation form of the time, such as in the Format,
                Hour, and Year methods. The methods Local, UTC, and In return a Time
                with a specific location. Changing the location in this way changes
                only the presentation; it does not change the instant in time being
                denoted and therefore does not affect the computations described in
                earlier paragraphs. \n Representations of a Time value saved by the
                GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store
                the Time.Location's offset, but not the location name. They therefore
                lose information about Daylight Saving Time. \n In addition to the
                required “wall clock” reading, a Time may contain an optional reading
                of the current process's monotonic clock, to provide additional precision
                for comparison or subtraction. See the “Monotonic Clocks” section
                in the package documentation for details. \n Note that the Go == operator
                compares not just the time instant but also the Location and the monotonic
                clock reading. Therefore, Time values should not be used as map or
                database keys without first guaranteeing that the identical Location
                has been set for all values, which can be achieved through use of
                the UTC or Local method, and that the monotonic clock reading has
                been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
                to t == u, since t.Equal uses the most accurate comparison available
                and correctly handles the case when only one of its arguments has
                a monotonic clock reading."
              type: object
            version:
              type: string
          required:
          - created
          - id
          - label
          - region
          - status
          - tags
          - updated
          - version
          type: object
      type: object
  version: v1alpha1
  versions:
  - name: v1alpha1
    served: true
    storage: true
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
